; __imul: signed 16-bit multiply
; r1 = a
; r2 = b
; r3 = sign
; returns result in r0

__imul:
	; set up sign
	PUSHR r1
	PUSH16 0
	CMP

	JGT __imul_a_pos
	PUSH16 1
	POPR  r3
	PUSHR r1
	NEG
	POPR  r1

__imul_a_pos:
	PUSHR r2
	PUSH16 0
	CMP

	JGT __imul_loop
	PUSH16 1
	PUSHR r3
	XOR
	POPR  r3
	PUSHR r2
	NEG
	POPR  r2

__imul_loop:
	PUSHR r2
	PUSH16 0
	CMP

	JEQ __imul_sign_check

	; if b is not zero
	PUSHR r0
	PUSHR r1
	ADD
	POPR  r0

	PUSHR r2
	PUSH16 1
	SUB
	POPR  r2

	JMP   __imul_loop

__imul_sign_check:
	PUSHR r3
	PUSH16 0
	CMP

	JEQ __imul_end
	PUSHR r0
	NEG
	POPR  r0
	
__imul_end:
	RET

; __idivmod: signed 16-bit division and modulo
; r2 = dividend (a)
; r3 = divisor  (b)
; r0 = quotient (a / b)
; r1 = remainder (a % b)
; r4 = sign tracker (0 = positive, 1 = negative)

__idivmod:
    ; handle division by zero (optional: return 0/0)
    PUSHR r3
    PUSH16 0
    CMP
    JEQ __idivmod_zero

    ; initialize quotient and sign tracker
    PUSH16 0
    POPR r0      ; r0 = 0
    PUSH16 0
    POPR r4      ; r4 = 0 (sign tracker)

    ; handle dividend sign
    PUSHR r2
    PUSH16 0
    CMP
    JGT __div_a_pos
    PUSHR r2
    NEG
    POPR r2
    PUSHR r4
    PUSH16 1
    XOR
    POPR r4
__div_a_pos:

    ; handle divisor sign
    PUSHR r3
    PUSH16 0
    CMP
    JGT __div_b_pos
    PUSHR r3
    NEG
    POPR r3
    PUSHR r4
    PUSH16 1
    XOR
    POPR r4
__div_b_pos:

    ; repeated subtraction loop
__div_loop:
    PUSHR r2
    PUSHR r3
    CMP
    JLT __div_done    

    ; subtract divisor from dividend
    PUSHR r2
    PUSHR r3
    SUB
    POPR r2

    ; increment quotient
    PUSHR r0
    PUSH16 1
    ADD
    POPR r0

    JMP __div_loop

__div_done:
    ; remainder = dividend
    PUSHR r2
    POPR r1

    ; apply quotient sign
    PUSHR r4
    PUSH16 0
    CMP
    JEQ __div_end
    PUSHR r0
    NEG
    POPR r0

__div_end:
    RET

__idivmod_zero:
    PUSH16 0
    POPR r0
    PUSH16 0
    POPR r1
    RET
