; print char from r0 without using `PRINT` and `MVCUR`
@define VIDEO_BASE   = 0x8000
@define CURSOR_POS   = 0x81e0
@define NEWLINE      = 0xA
@define VIDEO_WIDTH  = 40

@section data
hello_msg = "hello, world!\n"

@section text
main:
    ; Load address of hello_msg string
    data hello_msg       ; Load address of string into... (need to handle this)
    
    ; We need a way to get the string address into a register
    ; Let's use a different approach - load each character manually
    
    ; Print 'h' (0x68)
    movi r0 0x68
    call print
    
    ; Print 'e' (0x65)  
    movi r0 0x65
    call print
    
    ; Print 'l' (0x6c)
    movi r0 0x6c
    call print
    
    ; Print 'l' (0x6c)
    movi r0 0x6c
    call print
    
    ; Print 'o' (0x6f)
    movi r0 0x6f
    call print
    
    ; Print ',' (0x2c)
    movi r0 0x2c
    call print
    
    ; Print ' ' (0x20)
    movi r0 0x20
    call print
    
    ; Print 'w' (0x77)
    movi r0 0x77
    call print
    
    ; Print 'o' (0x6f)
    movi r0 0x6f
    call print
    
    ; Print 'r' (0x72)
    movi r0 0x72
    call print
    
    ; Print 'l' (0x6c)
    movi r0 0x6c
    call print
    
    ; Print 'd' (0x64)
    movi r0 0x64
    call print
    
    ; Print '!' (0x21)
    movi r0 0x21
    call print
    
    ; Print newline (0x0a) - this will trigger newline_case
    movi r0 0x0a
    call print
    
    halt

@section text
print:
    ; Load cursor position address into r2
    ; 0x81e0 = high byte 0x81, low byte 0xe0
    movi r2 0x81         ; Load high byte
    shli r2 8            ; Shift left 8 bits
    ori  r2 0xe0         ; OR in low byte (r2 = 0x81e0)
    
    ; Load current cursor value from memory into r1
    ldw  r1 r2 0         ; r1 = *r2 (cursor position)
    
    ; Check if r0 is newline (0xA)
    movi r3 0xA          ; r3 = NEWLINE
    mov  r4 r0           ; r4 = copy of character for comparison
    sub  r4 r4 r3        ; r4 = r0 - NEWLINE (sets flags, r4 destroyed)
    jeq  newline_case    ; Jump if equal (r0 == NEWLINE)
    
    ; --- normal character case ---
    ; Calculate video memory address: VIDEO_BASE + cursor_pos
    ; 0x8000 = high byte 0x80, low byte 0x00
    movi r3 0x80         ; Load high byte of VIDEO_BASE
    shli r3 8            ; Shift left 8 bits (r3 = 0x8000)
    add  r3 r3 r1        ; r3 = VIDEO_BASE + cursor_pos
    
    ; Write the character to video memory
    stb  r3 r0 0         ; Store byte r0 at address r3
    
    ; Increment cursor by 1
    addi r1 1            ; r1 = cursor_pos + 1
    stw  r2 r1 0         ; Store updated cursor position
    
    ret

newline_case:
    ; cursor = ((cursor / VIDEO_WIDTH) + 1) * VIDEO_WIDTH
    ; Calculate current line number by dividing cursor by 40
    movi r3 40           ; r3 = VIDEO_WIDTH
    movi r4 0            ; r4 = line counter (quotient)
    mov  r5 r1           ; r5 = copy of cursor position (dividend)
    
div_loop:
    ; Check if r5 >= 40
    mov  r0 r5           ; r0 = current remainder (reusing r0 temporarily)
    sub  r0 r0 r3        ; r0 = remainder - 40
    jlt  div_done        ; If remainder < 40, we're done dividing
    mov  r5 r0           ; r5 = remainder - 40 (update remainder)
    addi r4 1            ; quotient++
    jmp  div_loop
    
div_done:
    ; r4 now contains the line number
    ; Next line starts at (line_number + 1) * VIDEO_WIDTH
    addi r4 1            ; r4 = line_number + 1
    
    ; Multiply by VIDEO_WIDTH (40)
    ; 40 = 32 + 8, so we can use shifts: (r4 << 5) + (r4 << 3)
    mov  r5 r4           ; r5 = line_number + 1
    shli r4 5            ; r4 = (line_number + 1) << 5 = * 32
    shli r5 3            ; r5 = (line_number + 1) << 3 = * 8  
    add  r1 r4 r5        ; r1 = (line_number + 1) * 40
    
    ; Store updated cursor position
    stw  r2 r1 0         ; Store new cursor position
    
    ret
